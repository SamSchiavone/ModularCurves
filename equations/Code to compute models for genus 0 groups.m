// load "Congruence Subgroups of genus 0.m";
import "Required functions.m" : Act, SiegelExpansion, FindRelation, H90, CuspData;
import "Congruence Subgroups of genus 0.m" : CPlist;

function m2(A,K) 

 

// Input : A matrix A in GL_{3}(K) such that A preserves the equation for y^2=xz 

// Output : A matrix C in GL_{2}(K) corresponding to A  

 

a := A[1,1];  

b := A[1,2];  

c := A[1,3];  

d := A[2,1];  

e := A[2,2];  

f := A[2,3]; 

g := A[3,1]; 

h := A[3,2]; 

i := A[3,3]; 

if a eq 0 then 

    C := Matrix(K,2,2,[0,c,e,f]); 

else 

    if g eq 0 then 

        C := Matrix(K,2,2,[a,b/2,0,e]); 

    else 

        if c eq 0 then 

            C := Matrix(K,2,2,[a,0,d,e]); 

        else 

            if f eq 0 then 

                C := Matrix(K,2,2,[a,b/2,d,0]); 

            else 

                C := Matrix(K,2,2,[a,b/2,d,e-(b*d/(2*a))]); 

            end if; 

        end if; 

    end if; 

end if; 

 

return C; 

end function;  



function Conj(G,Gsup,M)
/*Input : Takes a group G and its supergroup Gsup (in GL(2,Integers(M))) up to conjugation;*/
/*Output: A conjugated group G such that G is a subset of Gsup*/

for H in Subgroups(Gsup) do;
if IsConjugate(GL(2,Integers(M)),H`subgroup,G) eq false then continue;
else
 _,A:=IsConjugate(GL(2,Integers(M)),H`subgroup,G);
 break;
 end if;
 end for;
 assert Conjugate(G,A) subset Gsup;
 return Conjugate(G,A),Gsup;
end function;

function ComputeModel(M1,Ggens,M2,Gsupgens,prec)
/* Input : Takes two genus 0 groups with generators Ggens and Gsupgens of level M1 and M2 respectively. If either group does not contain -I, then we take the group generated by Ggens (or Gsupgens) and -I;
prec is the precision with which q-expansions are computed, with subgroups upto LMFDB label "21.6.0.1" prec=10 works.
Output : The code computes model of X_{<Ggens>} and X_{<Gsupgens>} as a conic and computes the map J: X_{<Ggens>} \to X_{<Gsupgens>}. */

G0group := recformat<N:RngIntElt, sl2label:MonStgElt, gens>;
/*  N : GL_2 level of G
sl2label : Cummins-Pauli label of G \intersect SL_2(Z/NZ)
gens : A set of Generators for G in GL_2(Z/NZ)*/

Gamma:=rec<G0group | N := M1, gens := Ggens join {-Identity(GL(2,Integers(M1)))}>;
Gammasup:=rec<G0group | N := M2, gens := Gsupgens join {-Identity(GL(2,Integers(M2)))}>;
G:=sub<GL(2,Integers(M1))|[g: g in Gamma`gens]>;
Gsup:=sub<GL(2,Integers(M2))|[g: g in Gammasup`gens]>;
red:=hom<GL(2,Integers(M1))->GL(2,Integers(M2))|[GL(2,Integers(M2))!GL(2,Integers(M1)).i: i in [1..#Generators(GL(2,Integers(M1)))]]>;
Gsup:=Gsup@@red;
G,Gsup:=Conj(G,Gsup,M1);

/* Trying to find genus 0 congruence subgroup H such that G \intersect SL_2(Z) is conjugate to H. Once we find H, we conjugate generators of G so that
G \intersect \SL_2(Z)=H. */
for k in Keys(CPlist) do
    if k eq "1A" then 
               continue k;
         end if;
    Csub:=CPlist[k];        
    N:=Csub`N;
    H:=Csub`H;
         if IsDivisibleBy(M1,N) eq false then continue k;end if;
         red:=hom<SL(2,Integers(M1))->SL(2,Integers(N))|[SL(2,Integers(N))!SL(2,Integers(M1)).i: i in [1..#Generators(SL(2,Integers(M1)))]]>;
         Hred:=H@@red;
         b,Aconj:=IsConjugate(GL(2,Integers(M1)),G meet SL(2,Integers(M1)),Hred);
         if b eq false then 
               continue k;
         else 
               G:=Conjugate(G,Aconj);Gamma`sl2label:=k;break;end if;
 end for;

for k in Keys(CPlist) do
    if k eq "1A" then 
               continue k;
         end if;
    Csub:=CPlist[k];        
    N:=Csub`N;
    H:=Csub`H;
         if IsDivisibleBy(M1,N) eq false then continue k;end if;
         red:=hom<SL(2,Integers(M1))->SL(2,Integers(N))|[SL(2,Integers(N))!SL(2,Integers(M1)).i: i in [1..#Generators(SL(2,Integers(M1)))]]>;
         Hred:=H@@red;
         b,Aconj:=IsConjugate(GL(2,Integers(M1)),Gsup meet SL(2,Integers(M1)),Hred);
         if b eq false then 
               continue k;
         else 
               Gsup:=Conjugate(Gsup,Aconj);Gammasup`sl2label:=k;break;end if;
 end for;

 
 // We now construct cocycles that gives X_G and X_{Gsup} as a twist of X_H and X_Hsup; here H = G \intersect \SL_2(Z), Hsup = Gsup \intersect \SL_2(Z).
 
 L<z> := CyclotomicField(M1); 
 P<t> := FunctionField(L); 
 R<q>:=PuiseuxSeriesRing(L);
 h := CPlist[Gamma`sl2label]`hauptmodul; 
 hq:=CPlist[Gamma`sl2label]`h;
 H:= G meet SL(2,Integers(M1));
  _,width:=CuspData(H);
 w:=width[1];
 Hqtnt,q1:=quo<G|H>;
 
 hsup := CPlist[Gammasup`sl2label]`hauptmodul; 
 hsupq:=CPlist[Gammasup`sl2label]`h;
 Hsup:= Gsup meet SL(2,Integers(M1));
  _,widthsup:=CuspData(Hsup);
 wsup:=widthsup[1];
 Hsupqtnt,q2:=quo<Gsup|Hsup>;
 n:=Integers()!(Order(Gsup)/Order(G));
 Jh:=FindRelation(R!hq,R!hsupq,n);
 Gal,iota,sigma:=AutomorphismGroup(L);
 Cocycle1:=AssociativeArray();
 Cocycle2:=AssociativeArray();


for g in Gal do;
  for s1 in Set(Hqtnt) do;  
   d:=Determinant(s1@@q1);d:=Integers()!d;
   if sigma(g)(z) eq (z)^d then s:=s1; end if;
  end for;                    
  B1,B2:=Act(P!t,s@@q1,P!t,h);
  J:=FindRelation(R!SiegelExpansion(B2,prec),R!SiegelExpansion(h,prec),1);
  Cocycle1[g]:=J;
end for;

for g in Gal do;
  for s1 in Set(Hsupqtnt) do;  
   d:=Determinant(s1@@q2);d:=Integers()!d;
   if sigma(g)(z) eq (z)^d then s:=s1; end if;
  end for;                    
  B1,B2:=Act(P!t,s@@q2,P!t,hsup);
  J:=FindRelation(R!SiegelExpansion(B2,prec),R!SiegelExpansion(hsup,prec),1);
  Cocycle2[g]:=J;
end for;

 
m1 := map< MatrixRing(L,2) -> MatrixRing(L,3) | n :-> (1/Determinant(n))*Matrix(3,3,[n[1,1]^2,2*n[1,1]*n[1,2],n[1,2]^2,n[1,1]*n[2,1],n[1,1]*n[2,2]+n[1,2]*n[2,1],n[1,2]*n[2,2],n[2,1]^2,2*n[2,1]*n[2,2],n[2,2]^2])>;
phi1 := map<Gal -> MatrixRing(L,3) | [g -> m1([Evaluate(Numerator(Cocycle1[g])-Evaluate(Numerator(Cocycle1[g]),0),1),Evaluate(Numerator(Cocycle1[g]),0),Evaluate(Denominator(Cocycle1[g])-Evaluate(Denominator(Cocycle1[g]),0),1),Evaluate(Denominator(Cocycle1[g]),0)] ) : g in Gal]>; 
phi2 := map<Gal -> MatrixRing(L,3) | [g -> m1([Evaluate(Numerator(Cocycle2[g])-Evaluate(Numerator(Cocycle2[g]),0),1),Evaluate(Numerator(Cocycle2[g]),0),Evaluate(Denominator(Cocycle2[g])-Evaluate(Denominator(Cocycle2[g]),0),1),Evaluate(Denominator(Cocycle2[g]),0)] ) : g in Gal]>; 
Amatrix := H90(3,L,Rationals(),Gal,sigma,phi1);
Asupmatrix:=H90(3,L,Rationals(),Gal,sigma,phi2);
D := Matrix(3,3,[0,0,-1/2,0,1,0,-1/2,0,0]);  
Q0 := Conic(D); 
Q,_ := Conic(Transpose(Amatrix^(-1))*D*Amatrix^(-1));  // Transpose because MAGMA uses right action.
Q := ChangeRing(Q,Rationals());  // Q is conic for G.
Qsup,_:=Conic(Transpose(Asupmatrix^(-1))*D*Asupmatrix^(-1));
Qsup:=ChangeRing(Qsup,Rationals()); // Qsup is conic for Gsup.

boolean1,_:=HasRationalPoint(Q);
boolean2,_:=HasRationalPoint(Qsup);
            if boolean1 eq false and boolean2 eq false then 
            B:=Amatrix;
	          	B:=Matrix(R,3,3,[[R!B[i,j]:j in [1..3]]:i in [1..3]]);
		          funcx:=(B[1,1]*hq^2+B[1,2]*hq+B[1,3])/(B[3,1]*hq^2+B[3,2]*hq+B[3,3]);
		           funcy:=(B[2,1]*hq^2+B[2,2]*hq+B[2,3])/(B[3,1]*hq^2+B[3,2]*hq+B[3,3]); 
                
                W:=Matrix(L,[[Coefficient(funcx,i/w):i in [-1..prec]],[Coefficient(funcy,i/w):i in [-1..prec]],
                          [Coefficient(R!1,i/w):i in [-1..prec]],[Coefficient(-hq*funcx,i/w):i in [-1..prec]],
                          [Coefficient(-hq*funcy,i/w):i in [-1..prec]],[Coefficient(-hq,i/w):i in [-1..prec]]]);
		          null:=Nullspace(W);assert Dimension(null) eq 2;
		          A:=null.1;
		          Qx<x> := FunctionField(L);
		          Pol<yy> := PolynomialRing(Qx);
		           pol := Evaluate(DefiningPolynomial(Q),[x,yy,1]);
		           FFQ<y> := FunctionField(pol);
		           F:=(A[1]*x+A[2]*y+A[3])/(A[4]*x+A[5]*y+A[6]);
                   
		           J1:=Evaluate(Jh,F);
                   J1:=FFQ!J1;
                  
                   Asupmatrix:=Matrix(FFQ,3,3,[[FFQ!Asupmatrix[i,j]:j in [1..3]]:i in [1..3]]);
                   J:=[FFQ!((Asupmatrix[1,1]*J1^2+Asupmatrix[1,2]*J1+Asupmatrix[1,3])/(Asupmatrix[3,1]*J1^2+Asupmatrix[3,2]*J1+Asupmatrix[3,3])),FFQ!((Asupmatrix[2,1]*J1^2+Asupmatrix[2,2]*J1+Asupmatrix[2,3])/(Asupmatrix[3,1]*J1^2+Asupmatrix[3,2]*J1+Asupmatrix[3,3]))];
			   return Q,Qsup,J,boolean1,boolean2;
            end if;
            
             if boolean1 eq false and boolean2 eq true then 
            B:=Amatrix;
	          	B:=Matrix(R,3,3,[[R!B[i,j]:j in [1..3]]:i in [1..3]]);
		          funcx:=(B[1,1]*hq^2+B[1,2]*hq+B[1,3])/(B[3,1]*hq^2+B[3,2]*hq+B[3,3]);
		           funcy:=(B[2,1]*hq^2+B[2,2]*hq+B[2,3])/(B[3,1]*hq^2+B[3,2]*hq+B[3,3]); 
                
                W:=Matrix(L,[[Coefficient(funcx,i/w):i in [-1..prec]],[Coefficient(funcy,i/w):i in [-1..prec]],
                          [Coefficient(R!1,i/w):i in [-1..prec]],[Coefficient(-hq*funcx,i/w):i in [-1..prec]],
                          [Coefficient(-hq*funcy,i/w):i in [-1..prec]],[Coefficient(-hq,i/w):i in [-1..prec]]]);
		          null:=Nullspace(W);assert Dimension(null) eq 2;
		          A:=null.1;
		          Qx<x> := FunctionField(L);
		          Pol<yy> := PolynomialRing(Qx);
		           pol := Evaluate(DefiningPolynomial(Q),[x,yy,1]);
		           FFQ<y> := FunctionField(pol);
		           F:=(A[1]*x+A[2]*y+A[3])/(A[4]*x+A[5]*y+A[6]);
                   
		           J1:=Evaluate(Jh,F);
                   Bsup:=(Transpose(ParametrizationMatrix(Qsup)))^(-1);
                   Csup:=m2(Bsup*Asupmatrix,L);
                   J:=(Csup[1,1]*J1+Csup[1,2])/(Csup[2,1]*J1+Csup[2,2]);
			   return Q,Qsup,J,boolean1,boolean2;
            end if;
            if boolean1 eq true then
                B := (Transpose(ParametrizationMatrix(Q)))^(-1); //Transpose to make it left action 
                Bsup:=(Transpose(ParametrizationMatrix(Qsup)))^(-1);
                C := m2(B*Amatrix,L); 
                C:=Matrix(R,2,2,[[R!C[i,j]:j in [1..2]]:i in [1..2]]);
                Csup:=m2(Bsup*Asupmatrix,L);
                Csup:=Matrix(R,2,2,[[R!Csup[i,j]:j in [1..2]]:i in [1..2]]);
                g1:=(C[1,1]*hq+C[1,2])/(C[2,1]*hq+C[2,2]);
                g2:=(Csup[1,1]*hsupq+Csup[1,2])/(Csup[2,1]*hsupq+Csup[2,2]);
                n:=Integers()!(Order(Gsup)/Order(G));
                J:=FindRelation(g1,g2,n);
                assert J in FunctionField(Rationals()); 
                return Q,Qsup, J, boolean1,boolean2;

end if;



end function;
